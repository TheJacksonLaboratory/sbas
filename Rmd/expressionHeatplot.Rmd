---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: R
    language: R
    name: ir
---

# **Gene Expression Heatplot**
This notebook generates a heat plot representing sex-biased differential gene expression as well as a plot showing the counts of differentially expressed genes per tissue.

The values in the heatmap represent the correlation (similarity in the fold-changes) between male and female samples, with the values in the heatmap being the correlation between the vectors of fold changes of the tissues.

The assumptions made before rendering the heatmaps 
1. Get differential gene expression (DGE) files
2. Use the ``../assets/tissues.tsv`` to limit the tissues to those with at least 50 samples in each sex (``tissues.tsv`` was produced by a Python script)
3. Use the pattern for the differentially expressed genes **"../data/*DGE.csv"** to get all the values for the matrix.


## **Running this notebook**:

See the README for setting up prerequisites for the notebook.


## 1. Setup 

Assumes the `countGenesAndEvents.ipynb` notebook was run -- unpacking the results from the differential Gene Expression Analysis as run in the `differentialGeneExpressionAnalysis.ipynb` notebook.

```{r}
defaultW <- getOption("warn")  # suppress warnings for this cell
options(warn = -1) 

library(stringr)
library(edgeR)
library(pheatmap)
library(magrittr)
library(dplyr)
library(ggplot2)
library(scales)
library(viridis)
library(scales)

Sys.setenv(TAR = "/bin/tar") # for gzfile

options(warn = defaultW)
```

## 2. Making the matrices


### 2.1 Read in all the differential Gene Expression Analysis results

```{r}
filenames <- list.files("../data", pattern="*_DGE.csv", all.files=FALSE, full.names=TRUE)
message("Number of DGE files found with *_DGE.csv pattern: ",length(filenames))
```

### 2.2 read in the curated "../assets/tissues.tsv" 

The **`../assets/tissues.tsv`** file contains an indication to include the tissue if the file has at least **50** samples in that tissue with either **male** or **female** sex reporting

```{r}
head(filenames)
# read in all requirements so that the stage is properly set -- 
# if it is clear here -- it will remain clear for the rest of the time
# tissues.tsv contains the subset of files desired for analysis.
tissue_reduction <- read.table(file="../assets/tissues.tsv", header=TRUE, sep="\t",
                               skipNul=FALSE, stringsAsFactors = FALSE)
colnames(tissue_reduction)  <- c("SMTSD","female","male","include","display_name")
tissue_reduction$SMTSD <- factor(snakecase::to_snake_case(as.character(tissue_reduction$SMTSD)))
# only include those tissues we wish to continue with
table(tissue_reduction$include)
tissue_reduction <- tissue_reduction[tissue_reduction$include==1,]

message("Number of tissues with >=50 samples each in ../assets/tissues.tsv (tissue_reduction)",
        paste(dim(tissue_reduction), collapse=" "))
```

### 2.3 model rownames from first file for the matrices

Arbitrarily using the first file, to obtain the ordered rownames for assignment to the remainder of the files in the construction of the matrix.

```{r}
fullfilename <-filenames[1]
logFC_mat    <- read.csv(fullfilename)
pVal_mat     <- logFC_mat
logFC_mat    <- logFC_mat[order(rownames(logFC_mat)),]
logFC_mat_rownames <- as.character(rownames(logFC_mat)) 
pVal_mat_rownames  <- logFC_mat_rownames
pVal_mat     <- logFC_mat
```

```{r}
head(logFC_mat)
```

### 2.4 function make_tissue_matrix_ready for the logFC values

This function makes a logFC matrix for each of the tissues from the **`tissue_DGE.tsv`** results. One for each of our **`tissues`** of interest.

```{r}
make_tissue_matrix_ready <- function (file) {
    filename        <- paste('../data',file,sep="/")
    logFC_mat       <- read.csv(filename)
    logFC_mat       <- logFC_mat[order(rownames(logFC_mat)),]
    logFC           <- as.matrix(as.numeric(logFC_mat$logFC),ncol=1)
    rownames(logFC) <- rownames(logFC_mat)
    return(logFC)
}

```

### 2.5 function make_pval_matrix_ready for the adjusted P values

This function makes an adjPVal matrix for each of the tissues from the **`tissue_DGE.tsv`** results.  One for each of our **`tissues`** of interest.

```{r}
make_pval_matrix_ready <- function (file) {
    filename        <- paste('../data',file,sep="/")
    pVal_mat       <- read.csv(filename)
    pVal_mat       <- pVal_mat[order(rownames(pVal_mat)),]
    pVal           <- as.matrix(as.numeric(pVal_mat$adj.P.Val),ncol=1)
    rownames(pVal) <- rownames(pVal_mat)
    return(pVal)
}
```

### 2.6 Use lapply and call make_tissue_matrix_ready

With all of the files, prepare a logFC matrix.

```{r}
matrix_list <- lapply(X=filenames, FUN=make_tissue_matrix_ready)
message("Length of matrix_list", length(matrix_list))
```

### 2.7 Use lapply and call make_pval_matrix_ready

With all of the files, prepare the pVal matrix.

```{r}
pVal_matrix_list <- lapply(X=filenames, FUN=make_pval_matrix_ready)
message("Length of pVal_matrix_list: ", length(pVal_matrix_list))
```

```{r}
# rows are the number of samples, columns are the tissues
logFC_mat = as.matrix(lapply(X   = matrix_list, 
                             FUN = cbind),
                             nrow = nrow(logFC_mat), 
                             ncol = length(matrix_list))
message("Length of logFC_mat (corresponds to number of tissues from DGE files): ", length(logFC_mat))
```

```{r}
# rows are the number of samples, columns are the tissues
pVal_mat = as.matrix(lapply(X    = pVal_matrix_list, 
                            FUN  = cbind),
                            nrow = nrow(logFC_mat), 
                            ncol = length(pVal_matrix_list))
message("Length of pVal_mat (corresponds to number of tissues from DGE files): ", length(pVal_mat))
```

```{r}
tissue_list  <- levels(factor(tissue_reduction$SMTSD))
message("Number of tissues with at least 50 samples for both sexes: ",length(tissue_list))
```

```{r}
logFC_mat = as.matrix(as.numeric(unlist(matrix_list[1]),nrow=length(tissue_list), ncol=1))
dim(logFC_mat)
head(logFC_mat)
for (i in (2:length(matrix_list))) {
    n = as.matrix(as.numeric(unlist(matrix_list[i]),nrow=length(tissue_list), ncol=1))
    logFC_mat = cbind(logFC_mat, n)
}

dim(logFC_mat)

display_name = ifelse(tissue_list == tissue_reduction$SMTSD, 
                                            tissue_reduction$display_name,
                                            logFC_mat_rownames)
head(display_name)
rownames(logFC_mat) = logFC_mat_rownames
colnames(logFC_mat) = display_name
head(logFC_mat)

```

```{r}
pVal_mat = as.matrix(as.numeric(unlist(pVal_matrix_list[1]),nrow=length(tissue_list), ncol=1))
dim(pVal_mat)
head(pVal_mat)
for (i in (2:length(pVal_matrix_list))) {
    n = as.matrix(as.numeric(unlist(pVal_matrix_list[i]),nrow=length(tissue_list), ncol=1))
    pVal_mat = cbind(pVal_mat, n)
}

dim(pVal_mat)

display_name = ifelse(tissue_list == tissue_reduction$SMTSD, 
                                            tissue_reduction$display_name,
                                            pVal_mat_rownames)
head(display_name)
rownames(pVal_mat) = pVal_mat_rownames
colnames(logFC_mat) = display_name
head(logFC_mat)
```

### 2.8 Reduce the matrix to only those that pass FC > 1.5 and <= adjusted pVal < 0.05

Remove the cells in the matrix that are <= abs(log2(1.5)) preserving only the values that are FC >= 1.5 and adj.P.Val <= 0.05 (from a separate but coordinated matrix.

```{r}
logFC_ct <- rowSums(abs(logFC_mat) >= log2(1.5))
pVal_ct  <- rowSums(pVal_mat <= 0.05)

logFC_pass <- logFC_ct>1
table(logFC_pass)
pVal_pass  <-  pVal_ct>1
table(pVal_pass)

logFC_pVal_pass <- logFC_ct & pVal_ct
table(logFC_pVal_pass)

id <- logFC_pVal_pass

logFC_gt_1.5 <- logFC_mat[id,]

dim(logFC_gt_1.5)
head(logFC_gt_1.5)
```

### 2.9 Calculate the correlation between the tissues using the logFC

Calculate the correlation distances between the tissues using the logFC within each of the tissues.   Clustering by similar expression.

```{r}
# dist_mat all values logFC_mat
dist_mat <- as.matrix(cor(logFC_mat))
```

## 3. Render the heatmaps of the distance correlations


### 3.1 heatmap logFC

```{r}
pheatmap(as.matrix(dist_mat), clustering_distance_rows = "correlation", clustering_distance_cols = "correlation", fontsize = 6)
hm.parameters <- list(dist_mat, fontsize = 6)
do.call("pheatmap", c(hm.parameters,  filename="../pdf/geneExpressionDistanceCorrelationHeatmapAlllogFC.pdf"))
```

### 3.2 heatmap normalize quantiles logFC_mat

```{r}
logFC_mat_NQ <- normalizeQuantiles(logFC_mat)
dist_mat <- as.matrix(cor(logFC_mat_NQ))
pheatmap(as.matrix(dist_mat), clustering_distance_rows = "correlation", clustering_distance_cols = "correlation", fontsize = 6)
hm.parameters <- list(dist_mat, fontsize = 6)
do.call("pheatmap", c(hm.parameters,  filename="../pdf/geneExpressionDistanceCorrelationAlllogFC_NQ.pdf"))
```

### 3.3 heatmap logFC >= 1.5 and adjusted p Value < 0.05

```{r}
# dist_mat all values with logFC_mat_gt_1.5 
dist_mat <- as.matrix(cor(logFC_gt_1.5))
pheatmap(as.matrix(dist_mat), clustering_distance_rows = "correlation", clustering_distance_cols = "correlation", fontsize = 6)
hm.parameters <- list(dist_mat, fontsize = 6)
do.call("pheatmap", c(hm.parameters,  filename="../pdf/geneExpressionDistanceCorrelationHeatmapAlllogFC_gt_1.5.pdf"))
```

### 3.4 heatmap normalize quantiles logFC >= 1.5 and adjusted pValue < 0.05

```{r}
# dist_mat all values with logFC_gt_1.5_mat normalizeQuantiles 
logFC_mat_gt_1.5_NQ <- normalizeQuantiles(logFC_gt_1.5)
dist_mat <- as.matrix(cor(logFC_mat_gt_1.5_NQ))
pheatmap(as.matrix(dist_mat), clustering_distance_rows = "correlation", clustering_distance_cols = "correlation", fontsize = 6)
hm.parameters <- list(dist_mat, fontsize = 6)
do.call("pheatmap", c(hm.parameters,  filename="../pdf/geneExpressionDistanceCorrelationHeatmapAlllogFC_gt_1.5NQ.pdf"))

```

### 3.5 save the logFC_mat_gt_1.5_NQ rds object

```{r}
rownames(dist_mat) <- colnames(logFC_mat_gt_1.5_NQ)
colnames(dist_mat) <- colnames(logFC_mat_gt_1.5_NQ)

message("Saving dist_mat object")
saveRDS(object = dist_mat, file = "../data/dist_mat.rds")
message("Done!")
```

## Appendix Metadata

For replicability and reproducibility purposes, we also print the following metadata:

### Appendix.1. Checksums with the sha256 algorithm
1. Checksums of **'artefacts'**, files generated during the analysis and stored in the folder directory **`data`**
2. List of environment metadata, dependencies, versions of libraries using `utils::sessionInfo()` and [`devtools::session_info()`](https://devtools.r-lib.org/reference/session_info.html)

```{r}
figure_id   = "expressionHeatmap"
```

### Appendix.2. Libraries

```{r}
dev_session_info   <- devtools::session_info()
utils_session_info <- utils::sessionInfo()

message("Saving `devtools::session_info()` objects in ../metadata/devtools_session_info.rds  ..")
saveRDS(dev_session_info, file = paste0("../metadata/", figure_id, "_devtools_session_info.rds"))
message("Done!\n")

message("Saving `utils::sessionInfo()` objects in ../metadata/utils_session_info.rds  ..")
saveRDS(utils_session_info, file = paste0("../metadata/", figure_id ,"_utils_info.rds"))
message("Done!\n")

dev_session_info$platform
dev_session_info$packages[dev_session_info$packages$attached==TRUE, ]
```

```{r}

```
